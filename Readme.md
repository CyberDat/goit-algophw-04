
# Опис роботи та результати вимірювань

## Генератор даних  
Генератор створює задану кількість унікальних елементів для тестування алгоритмів сортування. Було використано 4 набори даних з розміром:  
- 1 000  
- 10 000  
- 100 000  
- 1 000 000 елементів  

## Результати замірів часу виконання (секунди)

| Алгоритм          | Часова складність | 1 000          | 10 000         | 100 000         | 1 000 000       |
|-------------------|-------------------|----------------|----------------|-----------------|-----------------|
| Timsort (sorted)  | O(n log n)        | 0.00105        | 0.01407        | 0.39003         | 1.61431         |
| Timsort (list.sort)| O(n log n)       | 0.00100        | 0.01151        | 0.15278         | 1.37731         |
| Merge sort        | O(n log n)        | 0.00836        | 0.09078        | 0.99688         | 10.97530        |
| Insertion sort    | O(n²)             | 0.08748        | 11.04756       | 528.18714       | > 2 години (примусово зупинено) |

## Пояснення різниці між Timsort (sorted) та Timsort (list.sort)  
- **`sorted()`** — це функція, що приймає будь-який ітерабельний об'єкт (список, кортеж, рядок) і повертає новий відсортований список. Оригінальний об'єкт не змінюється. Можна використовувати для будь-яких ітерабельних структур.  
- **`.sort()`** — це метод списку, який змінює список на місці і не повертає значення. Працює тільки зі списками.  

## Висновки  
Порівняння замірів підтверджує, що **Timsort** (вбудований у Python) є найшвидшим алгоритмом серед досліджених.  
Складність алгоритму **Insertion sort** — квадратна, що призводить до значного уповільнення на великих об'ємах даних (понад 2 години для 1 000 000 елементів).  
Таким чином, використання вбудованих алгоритмів сортування Python є ефективним вибором у більшості випадків, адже вони поєднують переваги сортування злиттям та вставками, що значно підвищує продуктивність.
"""
